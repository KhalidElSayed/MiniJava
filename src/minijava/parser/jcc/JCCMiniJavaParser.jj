options {
    STATIC = false;
}

PARSER_BEGIN(JCCMiniJavaParser)

package minijava.parser.jcc;

import minijava.ast.*;
import java.util.ArrayList;
public class JCCMiniJavaParser {}

PARSER_END(JCCMiniJavaParser)

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   < "//" (~["\n","\r"])*  > //("\n" | "\r" | "\r\n") We dont want to force single line comments to end with new lines, because then a comment at the end of the file may fail to parse.
|   < "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
}

// keywords
TOKEN : {
    < BOOLEAN: "boolean" >
|   < CLASS: "class" >
|   < ELSE: "else" >
|   < EXTENDS: "extends" >
|   < FALSE: "false" >
|   < IF: "if" >
|   < INT: "int" >
|   < MAIN: "main" >
|   < NEW: "new" >
|   < NULL: "null" >
|   < PRINT: "System.out.println" >
|   < PUBLIC: "public" >
|   < RETURN: "return" >
|   < STATIC: "static" >
|   < STRING: "String" > // any problem with this being a keyword?
|   < THIS: "this" >
|   < TRUE: "true" >
|   < VOID: "void" >
|   < WHILE: "while" >
|   < LENGTH: "length" >
}

// identifiers
TOKEN : {
    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"_")* >
|   < INT_LITERAL: "0" | (["1"-"9"] (<DIGIT>)*) >
|   < LETTER: ["a"-"z"] | ["A"-"Z"] >
|   < DIGIT: ["0"-"9"] >
}

// misc
TOKEN : {
    < LPAREN: "(" >
|   < RPAREN: ")" >
|   < LBRACK: "[" >
|   < RBRACK: "]" >
|   < LBRACE: "{" >
|   < RBRACE: "}" >
|   < ADD: "+" >
|   < AND: "&&" >
|   < ASSIGN: "=" >
|   < BANG: "!" >
|   < COMMA: "," >
|   < DOT: "." >
|   < LTHAN: "<" >
|   < MINUS: "-" >
|   < MULT: "*" >
|   < SEMICOLON: ";" >
}

Program Program() : {MainClass mainClass;ClassDecl curClass; ArrayList<ClassDecl> classes = new ArrayList<ClassDecl>();}
{
    mainClass = MainClass() (    
     curClass = ClassDeclaration() 
    {classes.add(curClass);}
    )* <EOF>
    { return new Program(mainClass,new NodeList<ClassDecl>(classes)); }
}

MainClass MainClass() : {Token className;Token argName;Statement statement; }
{
    <CLASS> (className = <IDENTIFIER>) <LBRACE>
        <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN>
        <STRING> <LBRACK> <RBRACK> (argName=<IDENTIFIER>) <RPAREN> <LBRACE>
           (statement = Statement())
        <RBRACE>
    <RBRACE>
    
    {return new MainClass(className.image,argName.image,statement);}
}

ClassDecl ClassDeclaration() : { }
{
    <CLASS> <IDENTIFIER> ( <EXTENDS> <IDENTIFIER> )? <LBRACE>
        ( VarDeclaration() | MethodDeclaration() )*
    <RBRACE>
}

void VarDeclaration() : { }
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() : { }
{
    <PUBLIC> Type() <IDENTIFIER> <LPAREN> FormalList() <RPAREN> <LBRACE>
        ( MethodBody() )*
        <RETURN> Expression() <SEMICOLON>
    <RBRACE>
}

void MethodBody() : { }
{
	LOOKAHEAD(2) 
	VarDeclaration() 
| 	Statement()
}

void FormalList() : { }
{
    ( Type() <IDENTIFIER> ( <COMMA> Type() <IDENTIFIER> )* )?
}

void Type() : { }
{
    ( <INT> (<LBRACK> <RBRACK>)? )
|   <BOOLEAN>
|   <STRING>
|   <IDENTIFIER>
}

Statement Statement() : {Statement stm;Statement stmLocal; Expression exp; Expression tst; }
{
  (//A block of statements
  {ArrayList<Statement> stms = new ArrayList<Statement>();}  
    <LBRACE> ((stmLocal= Statement()) {stms.add(stmLocal);})* <RBRACE>
  {  stm = new Block(new NodeList<Statement>(stms));}
  )
|   ({Statement thn; Statement els;} <IF> <LPAREN> (tst = Expression()) <RPAREN>
       (thn =  Statement())
      <ELSE>
       (els= Statement())        
       {stm = new If(tst,thn,els);}
       )
|   ({ Statement body;} <WHILE> <LPAREN> (tst =  Expression()) <RPAREN>
       (body = Statement()) {return new While(tst,body);})
|   ( <PRINT> <LPAREN> (exp = Expression()) <RPAREN> <SEMICOLON> {return new Print(exp);})
|   ({Token id; Expression index = null; Expression assign;}(id = <IDENTIFIER> )( <LBRACK> (index = Expression()) <RBRACK> )?
    <ASSIGN> (assign = Expression()) <SEMICOLON> 
    
    {if(index!=null)
        stm =  new ArrayAssign(id.image,index,assign);
    else
         stm = new Assign(id.image,assign);
    }
     )
    
    {return stm;}
}

Expression Expression() : {Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{
	(exp = LThanTerm()) ( <AND>  cur = Expression() 
	 {
	       exps.add(cur);
	 })*
	 
	 {if(exps.isEmpty())
	       return exp;
	    else
	   {
	       
	       //ok, create a set of nested ands in some arbitrary order.
	       for(Expression e:exps)
	       {
	           exp = new And(exp,e);
	       }
	       return exp;
	   }
	 
	 }
}

Expression LThanTerm() : {Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{
    (exp =MinusTerm() ) (  <LTHAN>  cur = Expression() 
     {
           exps.add(cur);
     })*
     
     {if(exps.isEmpty())
           return exp;
        else
       {
           
           //ok, create a set of nested ands in some arbitrary order.
           for(Expression e:exps)
           {
               exp = new LessThan(exp,e);
           }
           return exp;
       }
     
     }
	
}

Expression MinusTerm() : {Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{
        (exp =AddTerm() ) (  <MINUS>  cur = Expression() 
     {
           exps.add(cur);
     })*
     
     {if(exps.isEmpty())
           return exp;
        else
       {
           
           //ok, create a set of nested ands in some arbitrary order.
           for(Expression e:exps)
           {
               exp = new MinusTerm(exp,e);
           }
           return exp;
       }
     
     }
}

Expression AddTerm() :{Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{
	 (exp =MultTerm() ) (  <ADD>  cur = Expression() 
     {
           exps.add(cur);
     })*
     
     {if(exps.isEmpty())
           return exp;
        else
       {
           
           //ok, create a set of nested ands in some arbitrary order.
           for(Expression e:exps)
           {
               exp = new AddTerm(exp,e);
           }
           return exp;
       }
     
     }
}

Expression MultTerm() :{Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{
	(exp =DotTerm() ) (  <MULT>  cur = Expression() 
     {     
           exps.add(cur);
     })*
     
     {if(exps.isEmpty())
           return exp;
        else
       {
           
           //ok, create a set of nested ands in some arbitrary order.
           for(Expression e:exps)
           {
               exp = new MultTerm(exp,e);
           }
           return exp;
       }
     
     }
}

Expression DotTerm() : {Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{
	   (exp =ArrayTerm() ) (  <DOT>  cur = DotRHS(exp) 
     {exp = cur;})*
     
      { return exp;}
     
}

Expression DotRHS(Expression lhs ) : {Expression mthd;ArrayList<Expression> args = new ArrayList<Expression>();}
{
	(<LENGTH>{return new ArrayLength(lhs);})//note: this may mean that our grammar does not allow identifiers to be named "length"
|({Token id;}	id=<IDENTIFIER> <LPAREN> (

 (mthd= Expression()) ({Expression arg =null;} <COMMA> (Expression() {args.add(arg);} ))* )? <RPAREN>
   { return new Call(lhs,id.image,new NodeList<Expression>(args));}
 )
}

Expression ArrayTerm() : { }
{
    {Expression term; Expression index = null;}
	term =TerminalExp() ( <LBRACK>  index=Expression() <RBRACK> )?
	{if(index!=null)
	   return new ArrayLookup(term,index);
	  else
	   return term;	
	}
}

Expression TerminalExp() : {Token id; Expression term; }
{
	(id = <INT_LITERAL> {return new IntegerLiteral(String.valueOf(id.image));})
| ( id= <IDENTIFIER> {return new IdentifierExp(id.image);})
|   <NEW> (term = NewRHS() {return term;})
|   <BANG> (term = Expression() {return new Not(term);})
|   <LPAREN>( term = Expression() {return term;}) <RPAREN>
|  ( <THIS> {return new This();})
|   (<TRUE>{return new BooleanLiteral(true);})
|  ( <FALSE>{return new BooleanLiteral(false);})
}

Expression NewRHS() : { }
{
 	({Expression exp;} <INT> <LBRACK> (exp = Expression()) <RBRACK> {return new NewArray(exp);})
 | ( {Token id;}(id = <IDENTIFIER>) <LPAREN> <RPAREN>{return new NewObject(id.image);})
}


