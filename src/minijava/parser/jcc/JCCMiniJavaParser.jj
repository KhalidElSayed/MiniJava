options {
    STATIC = false;
}

PARSER_BEGIN(JCCMiniJavaParser)

package minijava.parser.jcc;

import minijava.ast.*;

public class JCCMiniJavaParser {}

PARSER_END(JCCMiniJavaParser)

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   < "//" (~["\n","\r"])*  > //("\n" | "\r" | "\r\n") We dont want to force single line comments to end with new lines, because then a comment at the end of the file may fail to parse.
|   < "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
}

// keywords
TOKEN : {
    < BOOLEAN: "boolean" >
|   < CLASS: "class" >
|   < ELSE: "else" >
|   < EXTENDS: "extends" >
|   < FALSE: "false" >
|   < IF: "if" >
|   < INT: "int" >
|   < MAIN: "main" >
|   < NEW: "new" >
|   < NULL: "null" >
|   < PRINT: "System.out.println" >
|   < PUBLIC: "public" >
|   < RETURN: "return" >
|   < STATIC: "static" >
|   < STRING: "String" > // any problem with this being a keyword?
|   < THIS: "this" >
|   < TRUE: "true" >
|   < VOID: "void" >
|   < WHILE: "while" >
|   < LENGTH: "length" >
}

// identifiers
TOKEN : {
    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"_")* >
|   < INT_LITERAL: "0" | (["1"-"9"] (<DIGIT>)*) >
|   < LETTER: ["a"-"z"] | ["A"-"Z"] >
|   < DIGIT: ["0"-"9"] >
}

// misc
TOKEN : {
    < LPAREN: "(" >
|   < RPAREN: ")" >
|   < LBRACK: "[" >
|   < RBRACK: "]" >
|   < LBRACE: "{" >
|   < RBRACE: "}" >
|   < ADD: "+" >
|   < AND: "&&" >
|   < ASSIGN: "=" >
|   < BANG: "!" >
|   < COMMA: "," >
|   < DOT: "." >
|   < LTHAN: "<" >
|   < MINUS: "-" >
|   < MULT: "*" >
|   < SEMICOLON: ";" >
}

Program Program() : { }
{
    MainClass() ( ClassDeclaration() )* <EOF>
    { return null; }
}

void MainClass() : { }
{
    <CLASS> <IDENTIFIER> <LBRACE>
        <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN>
        <STRING> <LBRACK> <RBRACK> <IDENTIFIER> <RPAREN> <LBRACE>
            Statement()
        <RBRACE>
    <RBRACE>
}

void ClassDeclaration() : { }
{
    <CLASS> <IDENTIFIER> ( <EXTENDS> <IDENTIFIER> )? <LBRACE>
        ( VarDeclaration() | MethodDeclaration() )*
    <RBRACE>
}

void VarDeclaration() : { }
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() : { }
{
    <PUBLIC> Type() <IDENTIFIER> <LPAREN> FormalList() <RPAREN> <LBRACE>
        ( VarDeclaration() | Statement() )*
        <RETURN> Expression() <SEMICOLON>
    <RBRACE>
}

void FormalList() : { }
{
    ( Type() <IDENTIFIER> ( <COMMA> Type() <IDENTIFIER> )* )?
}

void Type() : { }
{
    ( <INT> (<LBRACK> <RBRACK>)? )
|   <BOOLEAN>
|   <STRING>
|   <IDENTIFIER>
}

void Statement() : { }
{
    <LBRACE> ( Statement() )* <RBRACE>
|   ( <IF> <LPAREN> Expression() <RPAREN>
        Statement()
      <ELSE>
        Statement() )
|   ( <WHILE> <LPAREN> Expression() <RPAREN>
        Statement() )
|   ( <PRINT> <LPAREN> Expression() <RPAREN> <SEMICOLON> )
|   ( <IDENTIFIER> ( <LBRACK> Expression() <RBRACK> )?
    <ASSIGN> Expression() <SEMICOLON> )
}

void Expression() : { }
{
	LThanTerm() ( <AND> Expression() )*
}

void LThanTerm() : { }
{
	MinusTerm() ( <LTHAN> Expression() )*
}

void MinusTerm() : { }
{
    AddTerm() ( <MINUS> Expression() )*
}

void AddTerm() : { }
{
	MultTerm() ( <ADD> Expression() )*
}

void MultTerm() : { }
{
	DotTerm() ( <MULT> Expression() )*
}

void DotTerm() : { }
{
	ArrayTerm() ( <DOT> DotRHS() )*
}

void DotRHS() : { }
{
	<LENGTH>
|	<IDENTIFIER> <LPAREN> ( Expression() ( <COMMA> Expression() )* )? <RPAREN>
}

void ArrayTerm() : { }
{
	TerminalExp() ( <LBRACK> Expression() <RBRACK> )?
}

void TerminalExp() : { }
{
	<INT_LITERAL>
|   <IDENTIFIER>
|   <NEW> NewRHS()
|   <BANG> Expression()
|   <LPAREN> Expression() <RPAREN>
|   <THIS>
|   <TRUE>
|   <FALSE>
}

void NewRHS() : { }
{
 	<INT> <LBRACK> Expression() <RBRACK>
 |  <IDENTIFIER> <LPAREN> <RPAREN>
}


